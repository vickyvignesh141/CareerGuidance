# -*- coding: utf-8 -*-
"""career_agent

Automatically generated by Colab.hi

Original file is located at
    https://colab.research.google.com/drive/1_B03M0w86kucBq23aQ04dWrYHNyD8G3G
"""

!pip install groq --quiet

import os
import json
import re
import matplotlib.pyplot as plt
from dotenv import load_dotenv
from groq import Groq
from typing import List

# Load variables from .env
load_dotenv()

# Access the API key
GROQ_API_KEY = os.getenv("GROQ_API_KEY")

# Initialize client
client = Groq(api_key=GROQ_API_KEY)


questions = [

    "What subjects do you enjoy the most in school?",
    "What hobbies or activities do you like?",
    "Do you prefer working with people, technology, or ideas?",
    "Do you like creative or analytical tasks more?",
    "What are your strengths or skills?",
    "Do you have any career ideas in mind already?",
    "Currently pursuing degree and course?"
]

def safe_split_topics(text: str) -> List[str]:
    # Try splitting by commas first, then newlines; fallback: split by semicolon or return whole text
    if not text:
        return []
    if "," in text:
        parts = [p.strip() for p in text.split(",") if p.strip()]
    elif "\n" in text:
        parts = [p.strip() for p in text.split("\n") if p.strip()]
    elif ";" in text:
        parts = [p.strip() for p in text.split(";") if p.strip()]
    else:
        parts = [text.strip()]
    return parts

def ask_student_questions():
    responses = {}
    print("üßë‚Äçüéì Please answer these questions (press Enter if not sure):\n")
    for q in questions:
        a = input(f"{q}\n‚û° ").strip()
        responses[q] = a
    print("\n‚úî All responses collected!\n")
    return responses

def career_recommendation_with_plan(student_responses: dict) -> str:
    prompt = "You are a career counselor. A student answered these questions:\n\n"
    for q, a in student_responses.items():
        prompt += f"{q}: {a}\n"
    prompt += (
        "\nBased on this, do the following:\n"
        "1) Recommend 3 suitable career paths and explain why each fits the student.\n"
        "2) Choose the top recommended career and label it clearly as 'Top Recommended Career: <name>'.\n"
        "3) Provide a concise step-by-step starter guide (short-term 6-12 months) for the top career.\n"
        "4) Provide a comma-separated list of 5 essential learning topics for the top career under the heading 'Topics:'.\n"
    )

    try:
        response = client.chat.completions.create(
            messages=[
                {"role": "system", "content": "You are a helpful career guidance assistant."},
                {"role": "user", "content": prompt}
            ],
            model="llama-3.3-70b-versatile"
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print("Groq API error:", e)
        return "Error: Unable to generate career recommendation."

# Fallback topic suggestions for common careers if LLM fails or user offline
FALLBACK_TOPICS = {
    "Research and Development Engineer": ["Materials Science", "CAD Design", "Prototyping", "Research Methods", "Python/MATLAB"],
    "Product Designer": ["Design Fundamentals", "CAD/Sketching", "User Research", "Prototyping", "Materials"],
    "Innovation Consultant": ["Design Thinking", "Problem Framing", "Market Research", "Rapid Prototyping", "Presentation Skills"]
}

def suggest_topics_for_career(career_name: str) -> List[str]:
    # Ask Groq for 5 essential learning topics (comma-separated). If Groq fails, use fallback.
    prompt = f"List 5 essential learning topics someone should study to become a {career_name}. Return only a simple comma-separated list."
    try:
        resp = client.chat.completions.create(
            messages=[
                {"role": "system", "content": "You are a concise career skills advisor."},
                {"role": "user", "content": prompt}
            ],
            model="llama-3.3-70b-versatile"
        )
        content = resp.choices[0].message.content.strip()
        topics = safe_split_topics(content)
        if len(topics) >= 3:
            return topics[:5]
    except Exception as e:
        print("Topic suggestion Groq error:", e)

    # fallback: try direct map or infer from career_name
    for key in FALLBACK_TOPICS:
        if key.lower() in career_name.lower():
            return FALLBACK_TOPICS[key]
    # generic fallback
    return ["Foundations", "Domain Knowledge", "Tools & Software", "Project Work", "Research Methods"]

def ask_known_subjects(required_topics: List[str]) -> (List[str], List[str]):
    """
    Ask the student which of the required topics/subjects they already know.
    Returns (known_topics, missing_topics)
    """
    print("\nNow I will ask which topics/subjects you already know.")
    print("If you're not sure, press Enter or type 'no' to mark as unknown.\n")

    known = []
    missing = []
    for t in required_topics:
        ans = input(f"Do you already know or have experience with '{t}'? (yes/no)\n‚û° ").strip().lower()
        if ans in ["yes", "y", "yeah", "have", "i do", "i know"]:
            known.append(t)
        else:
            missing.append(t)
    print(f"\nKnown topics: {known}")
    print(f"Missing topics (will be included in learning plan): {missing}\n")
    return known, missing

def generate_daily_schedule(goal, hours_per_day: float, topics: List[str]):
    if not topics:
        return {"goal": goal, "hours_per_day": hours_per_day, "schedule": {}, "note": "No topics to study ‚Äî you already know them all!"}
    time_per_topic = round(hours_per_day / len(topics), 2) if hours_per_day > 0 else 0
    plan = {t: f"{time_per_topic} hours" for t in topics}
    return {"goal": goal, "hours_per_day": hours_per_day, "schedule": plan}

def generate_weekly_schedule(goal, weekly_hours: float, topics: List[str]):
    if not topics:
        return {"goal": goal, "weekly_hours": weekly_hours, "schedule": {}, "note": "No topics to study ‚Äî you already know them all!"}
    hours_per_day = round(weekly_hours / 7, 2) if weekly_hours > 0 else 0
    time_per_topic = round(hours_per_day / len(topics), 2) if len(topics) > 0 else 0
    days = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"]
    schedule = {}
    for day in days:
        schedule[day] = {t: f"{time_per_topic} hours" for t in topics}
    return {"goal": goal, "weekly_hours": weekly_hours, "schedule": schedule}

PROGRESS_FILE = "progress.json"

def load_progress():
    try:
        return json.load(open(PROGRESS_FILE, "r"))
    except:
        return {}

def update_goal_progress(topic: str, percentage: int):
    data = load_progress()
    data[topic] = max(0, min(100, int(percentage)))
    json.dump(data, open(PROGRESS_FILE, "w"))
    return data

def show_progress_graph():
    data = load_progress()
    if not data:
        print("No progress data found.")
        return
    goals = list(data.keys())
    values = list(data.values())
    plt.figure(figsize=(8,4))
    plt.bar(goals, values)
    plt.ylim(0,100)
    plt.ylabel("Completion (%)")
    plt.title("Topic Progress Tracker")
    plt.xticks(rotation=45, ha="right")
    plt.grid(axis='y')
    plt.show()

def run_agent_flow():
    print("===== CAREER GUIDANCE AGENT =====")
    student = ask_student_questions()

    print("‚è≥ Generating career guidance (this may take a few seconds)...")
    career_text = career_recommendation_with_plan(student)
    print("\n====== CAREER RECOMMENDATION ======\n")
    print(career_text)

    # -------------------------------------------------------
    # NEW FEATURE: Extract 3 career recommendations
    # -------------------------------------------------------
    careers = re.findall(r"\d+\.\s*\*\*(.*?)\*\*", career_text)

    if len(careers) >= 3:
        print("\nüéØ Here are your recommended careers:")
        for i, c in enumerate(careers, 1):
            print(f"{i}. {c}")

        # Ask user to choose one
        while True:
            choice = input("\nWhich career do you want to choose? (1/2/3)\n‚û° ").strip()
            if choice in ["1", "2", "3"]:
                top_career = careers[int(choice) - 1]
                break
            else:
                print("‚ùå Invalid choice. Please enter 1, 2, or 3.")
    else:
        # fallback logic if extraction fails
        match = re.search(r"Top Recommended Career[:\-\s]*\**(.+?)\**", career_text, re.IGNORECASE)
        if match:
            top_career = match.group(1).strip()
        else:
            top_career = input("\nPlease enter the career you want to pursue:\n‚û° ").strip()

    print(f"\nüéØ Selected career: {top_career}")

    # Ask if user has known subjects
    user_knows_subjects = input("\nDo you already have a list of subjects you know related to this career? (yes/no)\n‚û° ").strip().lower()

    if user_knows_subjects in ["yes", "y"]:
        subjects_input = input("Enter the subjects you already know (comma-separated):\n‚û° ").strip()
        known_subjects = safe_split_topics(subjects_input)
    else:
        known_subjects = []

    # Suggest topics for selected career
    topics = suggest_topics_for_career(top_career)
    print(f"\nüìò Suggested core topics for {top_career}: {topics}")

    # Determine missing topics
    known, missing = ask_known_subjects(topics) if known_subjects == [] else (known_subjects, [t for t in topics if t not in known_subjects])

    # If no missing topics
    if not missing:
        print("\n‚úÖ You already know the suggested topics! Fetching an advanced plan...")
        adv_prompt = f"Provide an advanced 6-12 month plan to deepen skills for someone who already knows {', '.join(topics)} and is pursuing {top_career}."

        try:
            adv_resp = client.chat.completions.create(
                messages=[
                    {"role": "system", "content": "You are a career mentor for advanced learners."},
                    {"role": "user", "content": adv_prompt}
                ],
                model="llama-3.3-70b-versatile"
            )
            print("\nAdvanced plan:\n")
            print(adv_resp.choices[0].message.content.strip())
        except Exception as e:
            print("Could not fetch advanced plan:", e)

    else:
        print("\nüöÄ Building learning schedules focused on missing topics:", missing)

        # Ask time availability
        while True:
            try:
                daily_hours = float(input("‚è± Hours you can study daily (e.g., 2):\n‚û° ").strip())
                break
            except:
                print("Please enter a valid number.")

        while True:
            try:
                weekly_hours = float(input("‚è± Total weekly study hours (e.g., 10):\n‚û° ").strip())
                break
            except:
                print("Please enter a valid number.")

        daily_plan = generate_daily_schedule(top_career, daily_hours, missing)
        weekly_plan = generate_weekly_schedule(top_career, weekly_hours, missing)

        print("\n====== DAILY SCHEDULE (for missing topics) ======")
        print(daily_plan)

        print("\n====== WEEKLY SCHEDULE (for missing topics) ======")
        print(weekly_plan)

        # Starter guide
        starter_prompt = f"Give a concise step-by-step 6-12 month starter guide for someone who needs to learn these topics to become a {top_career}: {', '.join(missing)}."

        try:
            starter_resp = client.chat.completions.create(
                messages=[
                    {"role": "system", "content": "You are a practical study coach."},
                    {"role": "user", "content": starter_prompt}
                ],
                model="llama-3.3-70b-versatile"
            )
            print("\n====== STARTER STEP-BY-STEP GUIDE ======")
            print(starter_resp.choices[0].message.content.strip())
        except Exception as e:
            print("Could not fetch starter guide:", e)

        # Initialize progress tracking
        data = load_progress()
        changed = False
        for t in missing:
            if t not in data:
                data[t] = 0
                changed = True
        if changed:
            json.dump(data, open(PROGRESS_FILE, "w"))
            print("\nInitialized progress tracking for missing topics.")

    # Update progress now?
    while True:
        up = input("\nWould you like to update progress for any topic now? (yes/no)\n‚û° ").strip().lower()
        if up in ["yes", "y"]:
            topic = input("Topic name (exact):\n‚û° ").strip()
            pct = input("Completion percentage (0-100):\n‚û° ").strip()
            try:
                pct_i = int(pct)
                update_goal_progress(topic, pct_i)
                print(f"Saved progress: {topic} = {pct_i}%")
            except:
                print("Invalid percentage.")
        else:
            break

    # Show graph?
    sg = input("\nShow progress graph? (yes/no)\n‚û° ").strip().lower()
    if sg in ["yes", "y"]:
        show_progress_graph()

    print("\nüéâ All done! Run the agent again anytime.")

run_agent_flow()